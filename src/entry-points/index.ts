import {
  app,
  BrowserWindow,
  session,
  dialog,
  ipcMain as electronIpcMain,
} from "electron";
import { ipcMain } from "electron-typescript-ipc";
import fs from "fs";
import path from "path";
import util from "util";
import { download } from "electron-dl";
import { NsisUpdater } from "electron-updater";
// Or MacUpdater, AppImageUpdater

export default class AppUpdater {
  constructor() {
    const options = {
      requestHeaders: {
        // Any request headers to include here
      },
      provider: "generic",
      url: "https://example.com/auto-updates",
    };

    // const autoUpdater = new NsisUpdater(options);
    // autoUpdater.addAuthHeader(`Bearer ${token}`)
    // autoUpdater.checkForUpdatesAndNotify();
  }
}
// import DownloadManager from "electron-download-manager";

// DownloadManager.

import dotenv from "dotenv";
dotenv.config();
// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).

declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  // eslint-disable-line global-require
  app.quit();
}

import { spawn, exec, execFileSync, execFile } from "child_process";
import { Api, DownloadProps } from "../tools/ElectronApi";
// import { checkDates, getDownloadDS, searchScenes } from "../backend/usgs-api";
import {
  OutLayer,
  type ISceneState,
  type RunArgs,
  type USGSLayerType,
} from "../actions/main-actions";
import { FsWatcher } from "../backend/fs-watcher";
import type {
  CalculationSettings,
  INetworkSettings,
} from "../ui/network-settings/network-settings-state";
import { applyProxySettings } from "./proxy-settings";
import { SettingsChema, store } from "../backend/settings-store";
import { isNumber } from "lodash";
import {
  checkUserPermissons,
  setOpenLoginDialogHandler,
} from "../backend/usgs-api";

const fsWatcher = new FsWatcher(app);

const logPath = path.join(app.getPath("userData"), "log.txt");
if (!fs.existsSync(logPath)) {
  fs.writeFileSync(logPath, "");
}
const fLog = fs.openSync(logPath, "a");
const originalLog = console.log;
console.log = (...args) => {
  originalLog(...args);
  fs.appendFileSync(
    fLog,
    new Date().getTime() + " : [LOG] : " + JSON.stringify(args) + "\n"
  );
};
const originalError = console.error;
console.error = (...args) => {
  originalError(...args);
  fs.appendFileSync(
    fLog,
    new Date().getTime() + " : [ERROR] : " + JSON.stringify(args) + "\n"
  );
};

// Register renderer log handler early, before windows are created
electronIpcMain.on(
  "renderer-log",
  (event, data: { level: string; args: unknown[] }) => {
    try {
      const { level, args } = data;
      const timestamp = new Date().toISOString();
      let windowTitle = "Unknown Window";
      try {
        windowTitle = event.sender.getTitle() || "Unknown Window";
      } catch (e) {
        // If we can't get title, use sender ID
        windowTitle = `Window-${event.sender.id}`;
      }

      // Format message - args are already serialized in preload
      const formattedArgs = args.map((arg) => {
        if (arg === null || arg === undefined) {
          return String(arg);
        }
        if (
          typeof arg === "string" ||
          typeof arg === "number" ||
          typeof arg === "boolean"
        ) {
          return String(arg);
        }
        if (typeof arg === "object") {
          try {
            return JSON.stringify(arg, null, 2);
          } catch {
            return String(arg);
          }
        }
        return String(arg);
      });

      const message = formattedArgs.join(" ");

      // Log to console with window context
      const logMessage = `[${timestamp}] [${windowTitle}] [${level.toUpperCase()}] ${message}`;

      switch (level) {
        case "error":
          console.error(logMessage);
          break;
        case "warn":
          console.warn(logMessage);
          break;
        case "info":
          console.info(logMessage);
          break;
        default:
          console.log(logMessage);
      }

      // Also append to log file if available
      try {
        fs.appendFileSync(
          fLog,
          `${timestamp} : [${level.toUpperCase()}] [${windowTitle}] : ${message}\n`
        );
      } catch (e) {
        // Ignore file write errors
      }
    } catch (e) {
      // Don't break if log handling fails
      console.error("Error handling renderer log:", e);
    }
  }
);

// Renderer log handler registered - all logs from modal windows will be forwarded here

const createWindow = async () => {
  session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: Object.assign(
        {
          "Content-Security-Policy": [
            "style-src-elem 'https://api.mapbox.com' 'unsafe-inline'",
          ],
        },
        details.responseHeaders
      ),
    });
  });
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    title: "USGS Loader",
    height: 600,
    titleBarStyle: "hidden",
    // resizable: false,
    // roundedCorners: true,
    // frame: false,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      webSecurity: false,
    },
  });
  fsWatcher.setMainWindow(mainWindow);

  // Set up 403 error handler to open login dialog
  setOpenLoginDialogHandler(async (targetRoute?: string) => {
    // Trigger the login dialog via renderer
    mainWindow.webContents.send("open-login-dialog-403", {
      targetRoute: targetRoute || "/bounds",
    });
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
  const userSettingsPath = path.join(
    app.getPath("userData"),
    ".networkSettings"
  );

  ipcMain.handle<Api>("watchNetworkSettings", async () => {
    const userSettingsPath = path.join(
      app.getPath("userData"),
      ".networkSettings"
    );
    if (fs.existsSync(userSettingsPath)) {
      const settings = fs.readFileSync(userSettingsPath).toString();
      return JSON.parse(settings);
    }
    return {};
  });

  ipcMain.handle<Api>("download", async (_, sceneId: string, args: RunArgs) => {
    const publicPath = path.join(
      process.env.APP_DEV ? process.cwd() : process.resourcesPath,
      "public"
    );
    const appdataPath = path.join(app.getPath("userData"), "localStorage");
    const scenePath = path.join(appdataPath, sceneId);
    const calculationProcessPath = path.join(
      publicPath,
      "tasks/calculation.exe"
    );
    // const calculationProcess = spawn(calculationProcessPath, ["a", scenePath]);

    const runArgs: string[] = ["--path", `"${scenePath}"`];
    if (args.useQAMask) runArgs.push("--useQAMask");
    if (args.emissionCalcMethod)
      runArgs.push("--emissionCalcMethod", `"${args.emissionCalcMethod}"`);
    if (isNumber(args.emission))
      runArgs.push("--emission", args.emission.toString());
    Object.entries(args.outLayers).forEach(([outLayerKey, required]) => {
      if (required) runArgs.push(`--save${outLayerKey}`);
    });
    if (args.saveDirectory) runArgs.push("--out", `"${args.saveDirectory}"`);
    if (args.layerNamePattern)
      runArgs.push("--layerPattern", `"${args.layerNamePattern}"`);

    // const _execFile = util.promisify(execFile);
    // const calcProcess = execFile(calculationProcessPath, runArgs, (err, stdout, stderr) => {
    //   console.log({err, stdout, stderr})
    // })

    // console.log({calcProcess, })

    const calculationProcess = exec(
      `start /wait "Calculation of ${sceneId}" "${calculationProcessPath}" ${runArgs.join(
        " "
      )}`,
      (...args: any) => {
        console.log("Calculate", scenePath, JSON.stringify(args, null, 2));
      }
    );

    return `"${calculationProcessPath}" ${runArgs.join(" ")}`;
  });

  ipcMain.handle<Api>(
    "saveNetworkSettings",
    async (_, settings: INetworkSettings) => {
      applyProxySettings(app, mainWindow, settings.proxy);
      if (settings.proxy) {
        store.set("proxySettings", settings.proxy);
      } else {
        store.delete("proxySettings");
      }
    }
  );

  ipcMain.handle<Api>(
    "saveCalculationSettings",
    async (_, settings: CalculationSettings) => {
      if (settings.args) {
        store.set("calculationSettings", settings.args);
      } else {
        store.delete("calculationSettings");
      }
    }
  );

  ipcMain.handle<Api>("openExplorer", async (_, path_: string) => {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const appdataPath = path.join(app.getPath("userData"), "localStorage");
    spawn(`explorer`, [`/select,"${path.join(appdataPath, path_)}"`], {
      windowsVerbatimArguments: true,
    });
  });

  ipcMain.handle<Api>("watch", async () => {
    return fsWatcher.getState();
  });

  ipcMain.handle<Api>("selectFolder", async () => {
    const result = await dialog.showOpenDialog(mainWindow, {
      properties: ["openDirectory"],
    });
    if (result.canceled || result.filePaths.length === 0) {
      return null;
    }
    return result.filePaths[0];
  });

  ipcMain.handle<Api>("selectFile", async () => {
    const result = await dialog.showOpenDialog(mainWindow, {
      properties: ["openFile"],
      filters: [
        { name: "TIF Files", extensions: ["tif", "TIF"] },
        { name: "All Files", extensions: ["*"] },
      ],
    });
    if (result.canceled || result.filePaths.length === 0) {
      return null;
    }
    return result.filePaths[0];
  });

  ipcMain.handle<Api>("scanFolder", async (_, folderPath: string) => {
    const files: string[] = [];
    const suggestedMapping: Record<string, USGSLayerType> = {};

    if (!fs.existsSync(folderPath)) {
      return { files: [] };
    }

    const items = fs.readdirSync(folderPath);
    const layerTypes: USGSLayerType[] = [
      "ST_TRAD",
      "ST_ATRAN",
      "ST_URAD",
      "ST_DRAD",
      "SR_B6",
      "SR_B5",
      "SR_B4",
      "QA_PIXEL",
    ];

    for (const item of items) {
      const itemPath = path.join(folderPath, item);
      const stat = fs.statSync(itemPath);

      if (stat.isFile() && (item.endsWith(".TIF") || item.endsWith(".tif"))) {
        files.push(item);

        // Попытка автоматического определения типа слоя
        // Формат: {displayId}_{layerType}.TIF или {displayId}_T1_{layerType}.TIF
        const fileName = item.replace(/\.(TIF|tif)$/, "");

        // Проверяем паттерн _T1_{layerType}
        const t1Match = fileName.match(/_T1_(.+)$/);
        if (t1Match) {
          const potentialType = t1Match[1] as USGSLayerType;
          if (layerTypes.includes(potentialType)) {
            suggestedMapping[item] = potentialType;
            continue;
          }
        }

        // Проверяем паттерн _{layerType} в конце
        for (const layerType of layerTypes) {
          if (fileName.endsWith(`_${layerType}`)) {
            suggestedMapping[item] = layerType;
            break;
          }
        }
      }
    }

    return {
      files,
      suggestedMapping:
        Object.keys(suggestedMapping).length > 0 ? suggestedMapping : undefined,
    };
  });

  ipcMain.handle<Api>(
    "addExternalFolder",
    async (
      _,
      payload: {
        folderPath: string;
        fileMapping: Record<string, USGSLayerType>;
        metadata?: {
          displayId: string;
          entityId?: string;
          captureDate?: string;
          source?: string;
          city?: string;
          displayName?: string;
        };
      }
    ) => {
      fsWatcher.addExternalFolder(
        payload.folderPath,
        payload.fileMapping,
        payload.metadata
      );
    }
  );

  ipcMain.handle<Api>(
    "openMappingDialog",
    async (
      _event,
      payload: {
        folderPath: string;
        files: string[];
        suggestedMapping?: Record<string, USGSLayerType>;
      }
    ): Promise<{
      fileMapping: Record<string, USGSLayerType>;
      metadata?: {
        displayId: string;
        entityId?: string;
        captureDate?: string;
        source?: string;
        city?: string;
        displayName?: string;
      };
    } | null> => {
      return new Promise((resolve) => {
        let isResolved = false;
        const dialogWindow = new BrowserWindow({
          parent: mainWindow,
          modal: true,
          titleBarStyle: "hidden",
          width: 600,
          height: 900,
          resizable: true,
          title: "Map Files and Add Metadata",
          webPreferences: {
            preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
            webSecurity: false,
            nodeIntegration: false,
            contextIsolation: true,
          },
        });

        // Функция для очистки и разрешения промиса
        const cleanupAndResolve = (
          result: {
            fileMapping: Record<string, USGSLayerType>;
            metadata?: {
              displayId: string;
              entityId?: string;
              captureDate?: string;
              source?: string;
              city?: string;
              displayName?: string;
            };
          } | null
        ) => {
          if (isResolved) return;
          isResolved = true;

          // Удаляем listener перед закрытием окна
          try {
            electronIpcMain.removeListener(
              "mapping-dialog-result",
              resultHandler
            );
          } catch (e) {
            // Игнорируем ошибки при удалении listener
            console.error("Error removing listener:", e);
          }

          // Закрываем окно, если оно еще не закрыто
          try {
            if (!dialogWindow.isDestroyed()) {
              dialogWindow.close();
            }
          } catch (e) {
            // Игнорируем ошибки при закрытии
            console.error("Error closing window:", e);
          }

          resolve(result);
        };

        // Слушаем результат от диалога
        const resultHandler = (
          event: Electron.IpcMainEvent,
          result: {
            fileMapping: Record<string, USGSLayerType>;
            metadata?: {
              displayId: string;
              entityId?: string;
              captureDate?: string;
              source?: string;
              city?: string;
              displayName?: string;
            };
          } | null
        ) => {
          // Проверяем, что результат пришел от правильного окна
          if (event.sender === dialogWindow.webContents) {
            cleanupAndResolve(result);
          }
        };

        electronIpcMain.on("mapping-dialog-result", resultHandler);

        // Передаем данные через hash в URL
        const dialogData = {
          folderPath: payload.folderPath,
          files: payload.files,
          suggestedMapping: payload.suggestedMapping,
        };
        const data = encodeURIComponent(JSON.stringify(dialogData));
        dialogWindow.loadURL(
          `${MAIN_WINDOW_WEBPACK_ENTRY}#mapping-dialog:${data}`
        );

        // Show window immediately
        dialogWindow.show();

        // добавляем горячую клавишу F12 для переключения DevTools
        dialogWindow.webContents.on("before-input-event", (event, input) => {
          if (
            input.key === "F12" ||
            (input.control && input.shift && input.key === "I")
          ) {
            if (dialogWindow.webContents.isDevToolsOpened()) {
              dialogWindow.webContents.closeDevTools();
            } else {
              dialogWindow.webContents.openDevTools();
            }
          }
        });

        // Если окно закрыто без результата
        dialogWindow.on("closed", () => {
          cleanupAndResolve(null);
        });
      });
    }
  );

  ipcMain.handle<Api>(
    "openLoginDialog",
    async (
      _,
      payload: {
        username?: string;
        token?: string;
        autoLogin?: boolean;
        targetRoute?: string;
      }
    ): Promise<{ username: string; token: string } | null> => {
      const targetRoute = payload.targetRoute || "/bounds";

      // Always show dialog immediately, even if we have stored credentials
      // The dialog will handle auto-login and show "Checking permissions..." state
      const storedCreds = store.get("userdata") as
        | SettingsChema["userdata"]
        | undefined;

      return new Promise((resolve) => {
        let isResolved = false;

        // Always create and show dialog window immediately
        const dialogWindow = new BrowserWindow({
          parent: mainWindow,
          modal: true,
          titleBarStyle: "hidden",
          width: 500,
          height: 400,
          resizable: true,
          title: "USGS Authentication",
          webPreferences: {
            preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
            webSecurity: false,
          },
        });

        // Prepare data for dialog
        const dialogData = {
          username: payload.username || storedCreds?.username || "",
          token: payload.token || storedCreds?.token || "",
          autoLogin: payload.autoLogin ?? true,
        };

        // Передаем данные через hash в URL
        const data = encodeURIComponent(JSON.stringify(dialogData));
        dialogWindow.loadURL(
          `${MAIN_WINDOW_WEBPACK_ENTRY}#login-dialog:${data}`
        );

        // Show window immediately
        dialogWindow.show();

        // добавляем горячую клавишу F12 для переключения DevTools
        dialogWindow.webContents.on("before-input-event", (event, input) => {
          if (
            input.key === "F12" ||
            (input.control && input.shift && input.key === "I")
          ) {
            if (dialogWindow.webContents.isDevToolsOpened()) {
              dialogWindow.webContents.closeDevTools();
            } else {
              dialogWindow.webContents.openDevTools();
            }
          }
        });

        // Функция для очистки и разрешения промиса
        const cleanupAndResolve = (
          result: { username: string; token: string } | null
        ) => {
          if (isResolved) return;
          isResolved = true;

          // Удаляем listener перед закрытием окна
          try {
            electronIpcMain.removeListener(
              "login-dialog-result",
              resultHandler
            );
          } catch (e) {
            console.error("Error removing listener:", e);
          }

          // Закрываем окно, если оно еще не закрыто
          try {
            if (!dialogWindow.isDestroyed()) {
              dialogWindow.close();
            }
          } catch (e) {
            console.error("Error closing window:", e);
          }

          resolve(result);
        };

        // Слушаем результат от диалога
        const resultHandler = (
          event: Electron.IpcMainEvent,
          result: { username: string; token: string } | null
        ) => {
          // Проверяем, что результат пришел от правильного окна
          if (event.sender === dialogWindow.webContents) {
            if (result) {
              // Проверяем права доступа
              checkUserPermissons({
                username: result.username,
                token: result.token,
              })
                .then((response) => {
                  const { data } = response || {};
                  if (data?.data?.includes?.("download")) {
                    // Сохраняем креды
                    store.set("userdata", {
                      username: result.username,
                      token: result.token,
                    });
                    // Отправляем сообщение в renderer для обновления состояния
                    mainWindow.webContents.send("login-success", {
                      username: result.username,
                      token: result.token,
                      targetRoute,
                    });
                    cleanupAndResolve(result);
                  } else {
                    cleanupAndResolve(null);
                  }
                })
                .catch((e) => {
                  console.error("Error checking permissions:", e);
                  cleanupAndResolve(null);
                });
            } else {
              cleanupAndResolve(null);
            }
          }
        };

        electronIpcMain.on("login-dialog-result", resultHandler);

        // Если окно закрыто без результата
        dialogWindow.on("closed", () => {
          cleanupAndResolve(null);
        });
      });
    }
  );

  /**
   * remember download url list and may be download immediately
   */
  ipcMain.handle<Api>(
    "addRepo",
    async (
      _,
      { displayId, entityId, ds }: DownloadProps,
      alsoDownload: boolean
    ) => {
      const appdataPath = path.join(app.getPath("userData"), "localStorage");
      const scenePath = path.join(appdataPath, displayId);
      if (!fs.existsSync(scenePath)) {
        fs.mkdirSync(scenePath, { recursive: true });
      }
      const indexFilePath = path.join(scenePath, "index.json");
      const sceneState: ISceneState = {
        isRepo: true,
        calculation: 0,
        scenePath,
        entityId,
        displayId,
        donwloadedFiles: Object.assign(
          {},
          ...ds.map((item) => ({
            [item.layerName]: {
              url: item.url,
            },
          }))
        ),
        calculated: false,
      };
      fs.writeFileSync(indexFilePath, JSON.stringify(sceneState, null, 2));
      console.log({ indexFilePath, sceneState });
    }
  );

  ipcMain.handle(
    "getStoreValue",
    (event, key: keyof SettingsChema | string) => {
      return store.get(key);
    }
  );

  ipcMain.handle(
    "setStoreValue",
    (event, key: keyof SettingsChema, value: unknown) => {
      if (!value) {
        store.delete(key);
      }
      return store.set(key, value);
    }
  );

  mainWindow.webContents.session.on("will-download", (event, item) => {
    const fn = item.getFilename().split(".TIF")[0];
    const [dir, type] = fn.split("_T1_");
    const sceneId = dir + "_T1";
    // const sceneState = fsWatcher.getSceneState(sceneId);
    const appdataPath = path.join(app.getPath("userData"), "localStorage");
    const scenePath = path.join(appdataPath, sceneId);
    // 'LC08_L2SP_142021_20220915_20220922_02_T1_QA_PIXEL.tif'
    const layerPath = path.join(scenePath, item.getFilename());
    const indexPath = path.join(scenePath, "index.json");
    if (fs.existsSync(layerPath)) {
      const index: ISceneState = JSON.parse(
        fs.readFileSync(indexPath).toString()
      );
      const { size } = index.donwloadedFiles[type as USGSLayerType];
      if (size !== fs.statSync(layerPath).size) {
        fs.rmSync(layerPath);
      } else {
        event.preventDefault();
        return;
      }
    }
    item.setSavePath(layerPath);
    const totalSize = item.getTotalBytes();
    fsWatcher.setState(sceneId, (prev) => ({
      ...prev,
      donwloadedFiles: {
        ...prev.donwloadedFiles,
        [type]: {
          ...prev.donwloadedFiles[type as USGSLayerType],
          size: totalSize,
        },
      },
    }));
    item.on("updated", (event, state) => {
      if (state === "interrupted") {
        console.log("Download is interrupted but can be resumed");
      } else if (state === "progressing") {
        if (item.isPaused()) {
          console.log("Download is paused");
        } else {
          // console.log(`progress: ${item.getReceivedBytes() / totalSize}`);
        }
      }
    });
    item.once("done", (event, state) => {
      if (state === "completed") {
        console.log("Download successfully");
      } else {
        console.log(`Download failed: ${state}`);
      }
    });
  });

  if (fs.existsSync(userSettingsPath)) {
    // fs.readFile(userSettingsPath, (err, data) => {
    //   if (err) {
    //     app.exit(1);
    //   }
    // const settings = JSON.parse(data.toString()) as INetworkSettings;
    const settings = store.get("proxySettings") as
      | INetworkSettings["proxy"]
      | undefined;
    applyProxySettings(app, mainWindow, settings);
    // });
  }
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
/** window initialization */
app.on("window-all-closed", async () => {
  // eslint-disable-next-line no-constant-condition
  // while (true) {
  //   if (!(await fsWatcher.stillWorking())) {
  //     break;
  //   }
  //   await new Promise((resolve) => setTimeout(resolve, 5000));
  // }
  app.quit();
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
